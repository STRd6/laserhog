// Generated by CoffeeScript 1.4.0
var Player, canvas;

Player = function(I) {
  var GRAVITY, INVULNERABILITY_DURATION, MAX_SHIELD, PHYSICS, PLAYER_COLORS, actionDown, beams, drawHud, falling, fireBeam, jumping, laserParticleEffects, lastDirection, particleSizes, physics, self, shieldGradient, shooting;
  if (I == null) {
    I = {};
  }
  GRAVITY = Point(0, 2);
  MAX_SHIELD = 64;
  INVULNERABILITY_DURATION = 32;
  PLAYER_COLORS = ["#00F", "#F00", "#0F0", "#FF0", "orange", "#F0F", "#0FF"];
  Object.reverseMerge(I, {
    acceleration: Point(0, 0),
    controller: 0,
    cooldown: 0,
    destructable: true,
    disabled: 0,
    excludedModules: ["Movable"],
    height: 24,
    invulnerable: INVULNERABILITY_DURATION,
    mobile: true,
    opaque: true,
    score: 0,
    shielding: false,
    shieldStrength: MAX_SHIELD,
    speed: 6,
    solid: true,
    velocity: Point(0, 0),
    width: 16
  });
  I.acceleration = Point(I.acceleration.x, I.acceleration.y);
  I.velocity = Point(I.velocity.x, I.velocity.y);
  I.sprite = null;
  I.color = PLAYER_COLORS[I.controller];
  actionDown = engine.controller(I.controller).actionDown;
  jumping = false;
  falling = true;
  lastDirection = 1;
  shooting = false;
  PHYSICS = {
    platform: function() {
      I.shielding = false;
      shooting = false;
      if (jumping) {
        I.velocity.y += GRAVITY.scale(0.5).y;
      } else if (falling) {
        I.velocity.y += GRAVITY.y;
      } else {
        if (actionDown("A")) {
          jumping = true;
          I.velocity.y = -7 * GRAVITY.y - 2;
        } else if (actionDown("C")) {
          if (I.shieldStrength > 0) {
            I.shielding = true;
            I.shieldStrength -= 1;
          } else {
            I.disabled = 96;
          }
        }
      }
      if (!(I.shielding || I.disabled)) {
        I.shieldStrength = I.shieldStrength.approach(MAX_SHIELD, 0.25);
        if (actionDown("right")) {
          I.velocity.x += 2;
          lastDirection = 1;
        }
        if (actionDown("left")) {
          I.velocity.x -= 2;
          lastDirection = -1;
        }
        if (!actionDown("A")) {
          jumping = false;
        }
        shooting = actionDown("B");
        /*
                  if actionDown "up"
                    shooting = true
                  if actionDown "down"
                    shooting = true
        */

      }
      if (I.shielding || !(actionDown("left") || actionDown("right"))) {
        I.velocity.x = I.velocity.x.approach(0, 2);
      }
      return I.velocity.x = I.velocity.x.clamp(-8, 8);
    }
  };
  physics = PHYSICS.platform;
  particleSizes = [2, 8, 4, 6];
  drawHud = function(canvas) {
    var hudHeight, hudMargin, hudWidth, screenPadding;
    screenPadding = 5;
    hudWidth = 80;
    hudHeight = 40;
    hudMargin = 10;
    return canvas.withTransform(Matrix.translation(I.controller * (hudWidth + hudMargin) + screenPadding, 0), function(canvas) {
      var color;
      canvas.clearRect(0, 0, hudWidth, hudHeight);
      color = Color(I.color);
      color.a(0.5);
      canvas.fillColor(color);
      canvas.fillRoundRect(0, -5, hudWidth, hudHeight);
      canvas.fillColor("#FFF");
      canvas.fillText("PLAYER " + (I.controller + 1), 5, 12);
      return canvas.fillText("SCORE: " + I.score, 5, 28);
    });
  };
  laserParticleEffects = function(target) {
    engine.add({
      "class": "Emitter",
      duration: 10,
      sprite: Sprite.EMPTY,
      velocity: Point(0, 0),
      particleCount: 9,
      batchSize: 5,
      x: target.x,
      y: target.y,
      generator: {
        color: Color(255, 0, 0, 0.5),
        duration: 3,
        height: function(n) {
          return particleSizes.wrap(n);
        },
        maxSpeed: 5,
        velocity: function(n) {
          return Point.fromAngle(Random.angle()).scale(rand(5) + 1);
        },
        width: function(n) {
          return particleSizes.wrap(n);
        }
      }
    });
    return engine.add({
      "class": "Light",
      radius: 50,
      x: target.x,
      y: target.y,
      duration: 3,
      shadows: false,
      step: "I.radius = I.radius / 2"
    });
  };
  beams = [];
  fireBeam = function(sourcePoint, direction, sourceObject) {
    var endPoint, hitObject, nearestHit;
    if (nearestHit = engine.rayCollides(sourcePoint, direction, sourceObject)) {
      endPoint = nearestHit;
      hitObject = nearestHit.object;
    }
    if (endPoint) {
      laserParticleEffects(endPoint);
    } else {
      endPoint = direction.norm().scale(1000).add(sourcePoint);
    }
    beams.push([sourcePoint, endPoint]);
    if (hitObject != null ? hitObject.I : void 0) {
      if (hitObject.I.shielding || hitObject.I.invulnerable) {
        fireBeam(endPoint, Point.fromAngle(Random.angle()), hitObject);
        return hitObject.I.shieldStrength -= 5;
      } else if (hitObject.I.destructable) {
        if (hitObject === self) {
          I.score -= 1;
        } else if (hitObject.I["class"] === I["class"]) {
          I.score += 1;
        }
        return hitObject.destroy();
      }
    }
  };
  shieldGradient = function(strength, context) {
    var a, edgeAlpha, radgrad;
    radgrad = context.createRadialGradient(4, -4, 0, 0, 0, 16);
    a = 0.75 * strength / MAX_SHIELD;
    edgeAlpha = 0.75 + 0.25 * strength / MAX_SHIELD;
    radgrad.addColorStop(0, "rgba(255, 255, 255, " + a + ")");
    radgrad.addColorStop(0.25, "rgba(0, 255, 0, " + a + ")");
    radgrad.addColorStop(0.9, "rgba(0, 255, 0, " + a + ")");
    radgrad.addColorStop(1, "rgba(0, 200, 0, " + edgeAlpha + ")");
    return radgrad;
  };
  self = GameObject(I).extend({
    drawHUD: drawHud,
    solid: function() {
      return true;
    },
    illuminate: function(canvas) {
      var center;
      center = self.centeredBounds();
      if (I.invulnerable) {
        center.radius = Math.sin(I.age * Math.TAU / 36) * 16 + 24;
      } else if (I.disabled) {
        center.radius = rand(16) + 16;
      } else {
        center.radius = 32;
      }
      if (I.shielding || I.disabled || I.invulnerable) {
        canvas.fillCircle(center.x, center.y, center.radius, Light.radialGradient(center, canvas.context()));
      }
      return beams.each(function(beam) {
        canvas.strokeColor("#000");
        return canvas.drawLine(beam[0].x, beam[0].y, beam[1].x, beam[1].y, 2.25);
      });
    }
  });
  self.on("draw", function(canvas) {
    if (I.shielding) {
      canvas.drawCircle({
        x: 0,
        y: 0,
        radius: 16,
        color: shieldGradient(I.shieldStrength, canvas.context())
      });
    }
    return beams.each(function(beam) {
      canvas.strokeColor(I.color);
      return canvas.drawLine(beam[0].x, beam[0].y, beam[1].x, beam[1].y, 2);
    });
  });
  self.on("update", function() {
    var center, shootDirection, shootX, shootY;
    beams = [];
    if (I.cooldown > 0) {
      I.cooldown -= 1;
    }
    if (I.disabled > 0) {
      I.disabled -= 1;
    }
    if (I.invulnerable > 0) {
      I.invulnerable -= 1;
    }
    if (I.disabled) {
      I.velocity = I.velocity.add(Point.fromAngle(Random.angle()).scale(rand(4)));
    }
    if (engine.collides(self.bounds(0, 1), self)) {
      falling = false;
    } else {
      falling = true;
    }
    physics();
    I.velocity.x.abs().times(function() {
      if (!engine.collides(self.bounds(I.velocity.x.sign(), 0), self)) {
        return I.x += I.velocity.x.sign();
      } else {
        return I.velocity.x = 0;
      }
    });
    I.velocity.y.abs().times(function() {
      if (!engine.collides(self.bounds(0, I.velocity.y.sign()), self)) {
        return I.y += I.velocity.y.sign();
      } else {
        I.velocity.y = 0;
        return jumping = false;
      }
    });
    if (mouseDown.left) {
      shootDirection = mousePosition.subtract(I);
    } else if (shooting) {
      shootX = 0;
      shootY = 0;
      if (actionDown("left")) {
        shootX += -1;
      }
      if (actionDown("right")) {
        shootX += 1;
      }
      if (actionDown("up")) {
        shootY += -1;
      }
      if (actionDown("down")) {
        shootY += 1;
      }
      if (shootY === 0 && shootX === 0) {
        shootDirection = Point(lastDirection, 0);
      } else {
        shootDirection = Point(shootX, shootY);
      }
    }
    if (shootDirection && (I.cooldown === 0)) {
      I.cooldown += 15;
      Sound.play("laser");
      I.velocity = I.velocity.add(shootDirection.norm().scale(-8));
      engine.add({
        "class": "Light",
        intensity: 0.75,
        radius: 100,
        x: I.x + I.width / 2 + I.velocity.x,
        y: I.y + I.height / 2 + I.velocity.y,
        duration: 6,
        shadows: false,
        step: "I.radius = I.radius / 4"
      });
      center = self.centeredBounds();
      fireBeam(center, shootDirection, self);
    }
    if ((I.disabled % 4) === 3) {
      engine.add({
        "class": "Emitter",
        duration: 5,
        sprite: Sprite.EMPTY,
        velocity: Point(0, 0),
        particleCount: 9,
        batchSize: 5,
        x: I.x,
        y: I.y,
        generator: {
          color: I.color,
          duration: 15,
          height: function(n) {
            return particleSizes.rand();
          },
          maxSpeed: 5,
          velocity: function(n) {
            return Point.fromAngle(Random.angle()).scale(rand(3) + 2);
          },
          width: function(n) {
            return particleSizes.rand();
          }
        }
      });
    }
    I.x = I.x.clamp(I.width / 2, App.width - I.width / 2);
    if (I.y >= App.height + 100) {
      return self.destroy();
    }
  });
  self.on('destroy', function() {
    Sound.play("hit");
    engine.add({
      "class": "Emitter",
      duration: 10,
      sprite: Sprite.EMPTY,
      velocity: Point(0, 0),
      particleCount: 15,
      batchSize: 5,
      x: I.width / 2 + I.x,
      y: I.height / 2 + I.y,
      generator: {
        color: "rgba(200, 140, 235, 0.7)",
        duration: 3,
        height: function(n) {
          return particleSizes.wrap(n) * 3;
        },
        maxSpeed: 35,
        velocity: function(n) {
          return Point.fromAngle(Random.angle()).scale(rand(5) + 5);
        },
        width: function(n) {
          return particleSizes.wrap(n) * 3;
        }
      }
    });
    engine.add(Object.extend({}, I, {
      x: [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608].rand(),
      y: [0, -2 * I.height, -4 * I.height, -6 * I.height, -8 * I.height, -10 * I.height].rand(),
      disabled: 0,
      invulnerable: INVULNERABILITY_DURATION,
      shieldStrength: MAX_SHIELD
    }));
    return I.active = false;
  });
  return self;
};

canvas = $("canvas").pixieCanvas();

Engine.defaultModules.push("Gamepads");

window.engine = Engine({
  canvas: canvas,
  showFPS: true,
  zSort: true,
  FPS: 60
});

engine.add("Player", {
  x: App.width / 2,
  y: App.height / 2
});

engine.start();
