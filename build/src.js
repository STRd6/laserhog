// Generated by CoffeeScript 1.4.0
var Base, Player, canvas, p1;

Number.prototype.truncate = function() {
  if (this > 0) {
    return Math.floor(this);
  } else if (this < 0) {
    return Math.ceil(this);
  } else {
    return this;
  }
};

Base = function(I) {
  var self;
  if (I == null) {
    I = {};
  }
  self = GameObject(I).extend({
    solid: function() {
      return I.solid;
    }
  });
  return self;
};

Player = function(I) {
  var INVULNERABILITY_DURATION, MAX_SHIELD, PLAYER_COLORS, beams, fireBeam, self, shieldGradient;
  if (I == null) {
    I = {};
  }
  MAX_SHIELD = 64;
  INVULNERABILITY_DURATION = 1;
  PLAYER_COLORS = ["#00F", "#F00", "#0F0", "#FF0", "orange", "#F0F", "#0FF"];
  Object.reverseMerge(I, {
    acceleration: Point(0, 0),
    controller: 0,
    cooldown: 0,
    destructable: true,
    disabled: 0,
    falling: true,
    gravity: Point(0, 3600),
    height: 24,
    invulnerable: INVULNERABILITY_DURATION,
    jumping: false,
    lastDirection: 1,
    mobile: true,
    opaque: true,
    positionRemainder: Point(0, 0),
    recoil: 240,
    score: 0,
    shielding: false,
    shieldStrength: MAX_SHIELD,
    shieldStrengthMax: MAX_SHIELD,
    shooting: false,
    speed: 6,
    solid: true,
    velocity: Point(0, 0),
    width: 16
  });
  I.acceleration = Point(I.acceleration.x, I.acceleration.y);
  I.velocity = Point(I.velocity.x, I.velocity.y);
  I.sprite = null;
  I.color = PLAYER_COLORS[I.controller];
  beams = [];
  fireBeam = function(sourcePoint, direction, sourceObject) {
    var endPoint, hitObject, nearestHit;
    if (nearestHit = engine.rayCollides(sourcePoint, direction, sourceObject)) {
      endPoint = nearestHit;
      hitObject = nearestHit.object;
    }
    if (endPoint) {

    } else {
      endPoint = direction.norm().scale(1000).add(sourcePoint);
    }
    beams.push([sourcePoint, endPoint]);
    if (hitObject != null ? hitObject.I : void 0) {
      if (hitObject.I.shielding || hitObject.I.invulnerable) {
        fireBeam(endPoint, Point.fromAngle(Random.angle()), hitObject);
        return hitObject.I.shieldStrength -= 5;
      } else if (hitObject.I.destructable) {
        if (hitObject === self) {
          I.score -= 1;
        } else if (hitObject.I["class"] === I["class"]) {
          I.score += 1;
        }
        return hitObject.destroy();
      }
    }
  };
  shieldGradient = function(strength, context) {
    var a, edgeAlpha, radgrad;
    radgrad = context.createRadialGradient(4, -4, 0, 0, 0, 16);
    a = 0.75 * strength / I.shieldStrengthMax;
    edgeAlpha = 0.75 + 0.25 * strength / I.shieldStrengthMax;
    radgrad.addColorStop(0, "rgba(255, 255, 255, " + a + ")");
    radgrad.addColorStop(0.25, "rgba(0, 255, 0, " + a + ")");
    radgrad.addColorStop(0.9, "rgba(0, 255, 0, " + a + ")");
    radgrad.addColorStop(1, "rgba(0, 200, 0, " + edgeAlpha + ")");
    return radgrad;
  };
  self = GameObject(I).extend({
    solid: function() {
      return true;
    },
    illuminate: function(canvas) {
      var center;
      center = self.centeredBounds();
      if (I.invulnerable) {
        center.radius = Math.sin(I.age * Math.TAU / 36) * 16 + 24;
      } else if (I.disabled) {
        center.radius = rand(16) + 16;
      } else {
        center.radius = 32;
      }
      if (I.shielding || I.disabled || I.invulnerable) {
        canvas.fillCircle(center.x, center.y, center.radius, Light.radialGradient(center, canvas.context()));
      }
      return beams.each(function(beam) {
        canvas.strokeColor("#000");
        return canvas.drawLine(beam[0].x, beam[0].y, beam[1].x, beam[1].y, 2.25);
      });
    }
  });
  self.unbind(".Movable");
  self.on("draw", function(canvas) {
    if (I.shielding) {
      return canvas.drawCircle({
        x: 0,
        y: 0,
        radius: 16,
        color: shieldGradient(I.shieldStrength, canvas.context())
      });
    }
  });
  self.on("overlay", function(canvas) {
    return beams.each(function(beam) {
      return canvas.drawLine({
        color: I.color,
        start: beam[0],
        end: beam[1],
        width: 2
      });
    });
  });
  self.cooldown("cooldown");
  self.cooldown("disabled");
  self.cooldown("invulnerable");
  self.on("update", function(elapsedTime) {
    var center, p, shootDirection, shootX, shootY, truncatedDistance, xDist, yMoves;
    beams = [];
    if (I.disabled) {
      I.velocity = I.velocity.add(Point.fromAngle(Random.angle()).scale(rand(4)));
    }
    if (engine.collides(self.bounds(0, 1), self)) {
      I.falling = false;
    } else {
      I.falling = true;
    }
    self.physics(elapsedTime);
    self.processInput(elapsedTime);
    xDist = I.velocity.x * elapsedTime + I.positionRemainder.x;
    truncatedDistance = xDist.truncate();
    I.positionRemainder.x = xDist - truncatedDistance;
    truncatedDistance.abs().times(function() {
      if (!engine.collides(self.bounds(truncatedDistance.sign(), 0), self)) {
        return I.x += I.velocity.x.sign();
      } else {
        return I.velocity.x = 0;
      }
    });
    yMoves = (I.velocity.y * elapsedTime).abs();
    yMoves.times(function() {
      if (!engine.collides(self.bounds(0, I.velocity.y.sign()), self)) {
        return I.y += I.velocity.y.sign();
      } else {
        I.velocity.y = 0;
        return I.jumping = false;
      }
    });
    if (I.shooting) {
      shootX = 0;
      shootY = 0;
      p = self.controllerPosition().norm();
      if (p.x === 0 && p.y === 0) {
        shootDirection = Point(I.lastDirection, 0);
      } else {
        shootDirection = p;
      }
    }
    if (shootDirection && (I.cooldown === 0)) {
      I.cooldown += 0.5;
      Sound.play("laser");
      I.velocity = I.velocity.add(shootDirection.norm().scale(-I.recoil));
      center = self.centeredBounds();
      fireBeam(center, shootDirection, self);
    }
    I.x = I.x.clamp(I.width / 2, App.width - I.width / 2);
    if (I.y >= App.height + 100) {
      return self.destroy();
    }
  });
  self.on('destroy', function() {
    Sound.play("hit");
    engine.add(Object.extend({}, I, {
      x: [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 480, 512, 544, 576, 608].rand(),
      y: [0, -2 * I.height, -4 * I.height, -6 * I.height, -8 * I.height, -10 * I.height].rand(),
      velocity: Point(0, 0),
      disabled: 0,
      invulnerable: INVULNERABILITY_DURATION,
      shieldStrength: I.shieldStrengthMax
    }));
    return I.active = false;
  });
  self.include("Player.Controller");
  self.include("Player.HUD");
  self.include("Player.Input");
  self.include("Player.Physics");
  return self;
};

Player.Controller = function(I, self) {
  self.actionDown = engine.controller(I.controller).actionDown;
  self.controllerPosition = function() {
    return engine.controller(I.controller).position();
  };
  return {};
};

Player.HUD = function(I, self) {
  self.on("overlay", function(canvas) {
    var hudHeight, hudMargin, hudWidth, screenPadding;
    screenPadding = 5;
    hudWidth = 80;
    hudHeight = 40;
    hudMargin = 10;
    return canvas.withTransform(Matrix.translation(I.controller * (hudWidth + hudMargin) + screenPadding, 0), function(canvas) {
      var color, textColor;
      color = Color(I.color);
      color.a = 0.5;
      canvas.drawRoundRect({
        color: color,
        x: 0,
        y: -5,
        width: hudWidth,
        height: hudHeight
      });
      textColor = "#FFF";
      canvas.drawText({
        text: "PLAYER " + (I.controller + 1),
        x: 5,
        y: 12,
        color: textColor
      });
      return canvas.drawText({
        text: "SCORE: " + I.score,
        x: 5,
        y: 28,
        color: textColor
      });
    });
  });
  return {};
};

Player.Input = function(I, self) {
  return {
    processInput: function(dt) {
      var acc, dec, friction, jumpImpulse, p, sign;
      I.shielding = false;
      I.shooting = false;
      acc = 300;
      dec = 3000;
      friction = 1000;
      jumpImpulse = -600;
      p = self.controllerPosition();
      if (!(I.jumping || I.falling)) {
        if (self.actionDown("A")) {
          I.jumping = true;
          I.velocity.y = jumpImpulse;
        } else if (self.actionDown("B")) {
          if (I.shieldStrength > 0) {
            I.shielding = true;
            I.shieldStrength -= 1;
          } else {
            I.disabled = 3;
          }
        }
      }
      if (!(I.shielding || I.disabled)) {
        I.shieldStrength = I.shieldStrength.approach(I.shieldStrengthMax, 0.25);
        if (sign = p.x.sign()) {
          if (I.velocity.x.sign() !== sign) {
            debugger;
            I.velocity.x += dec * sign * dt;
          } else {
            I.velocity.x += acc * sign * dt;
          }
          I.lastDirection = sign;
        }
        if (!self.actionDown("A")) {
          I.jumping = false;
        }
        I.shooting = self.actionDown("C");
      }
      if (I.shielding || !p.x) {
        return I.velocity.x = I.velocity.x.approach(0, friction * dt);
      }
    }
  };
};

Player.Physics = function(I, self) {
  var PHYSICS, VELOCITY_MAX_X;
  VELOCITY_MAX_X = 300;
  PHYSICS = {
    platform: function(dt) {
      if (I.jumping) {
        I.velocity.y += I.gravity.scale(0.5).y * dt;
      } else if (I.falling) {
        I.velocity.y += I.gravity.y * dt;
      }
      return I.velocity.x = I.velocity.x.clamp(-VELOCITY_MAX_X, VELOCITY_MAX_X);
    }
  };
  self.physics = PHYSICS.platform;
  return {};
};

canvas = $("canvas").pixieCanvas();

Engine.defaultModules.push("Gamepads");

window.engine = Engine({
  backgroundColor: "#FFF",
  canvas: canvas,
  zSort: true,
  FPS: 60
});

p1 = engine.add("Player", {
  x: App.width / 2,
  y: App.height / 2
});

p1.include("Debuggable");

engine.add("Player", {
  controller: 1,
  x: App.width / 4,
  y: App.height / 2
});

engine.add("Base", {
  solid: true,
  x: App.width / 2,
  width: App.width,
  y: App.height - 10,
  height: 20,
  color: "green"
});

engine.collides = function(bounds, sourceObject) {
  return engine.objects().inject(false, function(collided, object) {
    return collided || ((typeof object.solid === "function" ? object.solid() : void 0) && (object !== sourceObject) && object.collides(bounds));
  });
};

engine.on("update", function() {
  if (justPressed.enter) {
    return engine.pause();
  }
});

engine.start();
